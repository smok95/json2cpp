// Auto-generated by json2cpp
// DO NOT EDIT

#pragma once

#include <string>
#include <vector>
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"

// pre-C++11 compatible Optional implementation
template<typename T>
struct Optional {
    bool has;
    T value;
    
    Optional() : has(false) {}
    Optional(const T& v) : has(true), value(v) {}
    
    bool IsValid() const { return has; }
    const T& Get() const { return value; }
    T& Get() { return value; }
    void Set(const T& v) { has = true; value = v; }
    void Clear() { has = false; }
};

typedef Optional<int> OptionalInt;
typedef Optional<int64_t> OptionalInt64;
typedef Optional<double> OptionalDouble;
typedef Optional<bool> OptionalBool;
typedef Optional<std::string> OptionalString;

struct MarketDataItem {
    double bid;
    double ask;
    double last;

    void FromJson(const rapidjson::Value& v) {
        if (v.HasMember("bid") && v["bid"].IsDouble()) {
            bid = v["bid"].GetDouble();
        }
        if (v.HasMember("ask") && v["ask"].IsDouble()) {
            ask = v["ask"].GetDouble();
        }
        if (v.HasMember("last") && v["last"].IsDouble()) {
            last = v["last"].GetDouble();
        }
    }

    void ToJson(rapidjson::Value& v, rapidjson::Document::AllocatorType& a) const {
        v.AddMember("bid", rapidjson::Value().SetDouble(bid), a);
        v.AddMember("ask", rapidjson::Value().SetDouble(ask), a);
        v.AddMember("last", rapidjson::Value().SetDouble(last), a);
    }
};

struct MetadataItem {
    std::string exchange;
    MarketDataItem market_data;

    void FromJson(const rapidjson::Value& v) {
        if (v.HasMember("exchange") && v["exchange"].IsString()) {
            exchange = std::string(v["exchange"].GetString());
        }
        if (v.HasMember("market_data") && v["market_data"].IsObject()) {
            market_data.FromJson(v["market_data"]);
        }
    }

    void ToJson(rapidjson::Value& v, rapidjson::Document::AllocatorType& a) const {
        {
            rapidjson::Value str_val;
            str_val.SetString(exchange.c_str(), a);
            v.AddMember("exchange", str_val, a);
        }
        {
            rapidjson::Value obj_val(rapidjson::kObjectType);
            market_data.ToJson(obj_val, a);
            v.AddMember("market_data", obj_val, a);
        }
    }
};

struct Order {
    int64_t id;
    std::string symbol;
    std::string side;
    int64_t quantity;
    double price;
    std::string type;
    std::string time_in_force;
    std::string status;
    std::string timestamp;
    std::vector<std::string> tags;
    MetadataItem metadata;
    OptionalString optional_field;

    void FromJson(const rapidjson::Value& v) {
        if (v.HasMember("id") && v["id"].IsInt64()) {
            id = v["id"].GetInt64();
        } else if (v.HasMember("id") && v["id"].IsInt()) {
            id = static_cast<int64_t>(v["id"].GetInt());
        }
        if (v.HasMember("symbol") && v["symbol"].IsString()) {
            symbol = std::string(v["symbol"].GetString());
        }
        if (v.HasMember("side") && v["side"].IsString()) {
            side = std::string(v["side"].GetString());
        }
        if (v.HasMember("quantity") && v["quantity"].IsInt64()) {
            quantity = v["quantity"].GetInt64();
        } else if (v.HasMember("quantity") && v["quantity"].IsInt()) {
            quantity = static_cast<int64_t>(v["quantity"].GetInt());
        }
        if (v.HasMember("price") && v["price"].IsDouble()) {
            price = v["price"].GetDouble();
        }
        if (v.HasMember("type") && v["type"].IsString()) {
            type = std::string(v["type"].GetString());
        }
        if (v.HasMember("time_in_force") && v["time_in_force"].IsString()) {
            time_in_force = std::string(v["time_in_force"].GetString());
        }
        if (v.HasMember("status") && v["status"].IsString()) {
            status = std::string(v["status"].GetString());
        }
        if (v.HasMember("timestamp") && v["timestamp"].IsString()) {
            timestamp = std::string(v["timestamp"].GetString());
        }
        if (v.HasMember("tags") && v["tags"].IsArray()) {
            const rapidjson::Value& arr = v["tags"];
            tags.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                if (arr[i].IsString()) {
                    tags.push_back(std::string(arr[i].GetString()));
                }
            }
        }
        if (v.HasMember("metadata") && v["metadata"].IsObject()) {
            metadata.FromJson(v["metadata"]);
        }
        if (v.HasMember("optional_field") && v["optional_field"].IsString()) {
            optional_field.Set(std::string(v["optional_field"].GetString()));
        } else {
            optional_field.Clear();
        }
    }

    void ToJson(rapidjson::Value& v, rapidjson::Document::AllocatorType& a) const {
        v.AddMember("id", rapidjson::Value().SetInt64(id), a);
        {
            rapidjson::Value str_val;
            str_val.SetString(symbol.c_str(), a);
            v.AddMember("symbol", str_val, a);
        }
        {
            rapidjson::Value str_val;
            str_val.SetString(side.c_str(), a);
            v.AddMember("side", str_val, a);
        }
        v.AddMember("quantity", rapidjson::Value().SetInt64(quantity), a);
        v.AddMember("price", rapidjson::Value().SetDouble(price), a);
        {
            rapidjson::Value str_val;
            str_val.SetString(type.c_str(), a);
            v.AddMember("type", str_val, a);
        }
        {
            rapidjson::Value str_val;
            str_val.SetString(time_in_force.c_str(), a);
            v.AddMember("time_in_force", str_val, a);
        }
        {
            rapidjson::Value str_val;
            str_val.SetString(status.c_str(), a);
            v.AddMember("status", str_val, a);
        }
        {
            rapidjson::Value str_val;
            str_val.SetString(timestamp.c_str(), a);
            v.AddMember("timestamp", str_val, a);
        }
        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<std::string>::const_iterator it = tags.begin(); it != tags.end(); ++it) {
                rapidjson::Value item_val;
                item_val.SetString(it->c_str(), a);
                arr.PushBack(item_val, a);
            }
            v.AddMember("tags", arr, a);
        }
        {
            rapidjson::Value obj_val(rapidjson::kObjectType);
            metadata.ToJson(obj_val, a);
            v.AddMember("metadata", obj_val, a);
        }
        if (optional_field.IsValid()) {
            rapidjson::Value str_val;
            str_val.SetString(optional_field.Get().c_str(), a);
            v.AddMember("optional_field", str_val, a);
        }
    }
};