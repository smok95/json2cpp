package codegen

import (
	"bytes"
	"fmt"
	"io"
	"json2cpp/internal/nameutil"
	"json2cpp/internal/types"
	"json2cpp/templates"
	"os"
	"path"
	"path/filepath"
)

// AdapterGenerator generates parser-agnostic C++ code using the adapter pattern
type AdapterGenerator struct {
	legacyCpp    bool
	namespace    string
	useCamelCase bool
	optionalNull bool
	outputDir    string
	usedNames    map[string]int
}

// NewAdapterGenerator creates a new adapter-based code generator
func NewAdapterGenerator(cfg Config, outputDir string) *AdapterGenerator {
	return &AdapterGenerator{
		legacyCpp:    cfg.LegacyCPP,
		namespace:    cfg.Namespace,
		useCamelCase: cfg.CamelCase,
		optionalNull: cfg.OptionalNull,
		outputDir:    outputDir,
		usedNames:    make(map[string]int),
	}
}

// GenerateFiles generates all necessary files (types.h, serializer.h, serializer.cpp, adapters)
func (g *AdapterGenerator) GenerateFiles(info *types.TypeInfo) error {
	// Sort structs by dependencies
	types.SortStructs(info.Structs)

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Copy adapter template files
	if err := g.copyAdapterTemplates(); err != nil {
		return fmt.Errorf("failed to copy adapter templates: %w", err)
	}

	// Generate types.h
	typesContent, err := g.generateTypes(info)
	if err != nil {
		return fmt.Errorf("failed to generate types.h: %w", err)
	}
	if err := g.writeFile("types.h", typesContent); err != nil {
		return err
	}

	// Generate serializer.h
	serializerHeader, err := g.generateSerializerHeader(info)
	if err != nil {
		return fmt.Errorf("failed to generate serializer.h: %w", err)
	}
	if err := g.writeFile("serializer.h", serializerHeader); err != nil {
		return err
	}

	// Generate serializer.cpp
	serializerImpl, err := g.generateSerializerImpl(info)
	if err != nil {
		return fmt.Errorf("failed to generate serializer.cpp: %w", err)
	}
	if err := g.writeFile("serializer.cpp", serializerImpl); err != nil {
		return err
	}

	return nil
}

// copyAdapterTemplates copies all adapter template files to the output directory
func (g *AdapterGenerator) copyAdapterTemplates() error {
	templateFiles := []string{
		"json_adapter.h",
		"rapidjson_adapter.h",
		"rapidjson_adapter.cpp",
		"nlohmann_adapter.h",
		"nlohmann_adapter.cpp",
		"jsoncpp_adapter.h",
		"jsoncpp_adapter.cpp",
	}

	// Read templates from embedded filesystem
	for _, filename := range templateFiles {
		// Use path.Join (not filepath.Join) because embed.FS always uses forward slashes
		templatePath := path.Join("adapter", filename)
		content, err := templates.FS.ReadFile(templatePath)
		if err != nil {
			return fmt.Errorf("failed to read embedded template %s: %w", templatePath, err)
		}

		if err := g.writeFile(filename, string(content)); err != nil {
			return err
		}
	}

	return nil
}

// generateTypes generates the types.h file with pure data structures
func (g *AdapterGenerator) generateTypes(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header comment and guard
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString("// Pure data structures (parser-independent)\n\n")
	buf.WriteString("#ifndef JSON2CPP_TYPES_H\n")
	buf.WriteString("#define JSON2CPP_TYPES_H\n\n")
	buf.WriteString("#include <string>\n")
	buf.WriteString("#include <vector>\n")

	// Include int64_t
	if g.legacyCpp {
		buf.WriteString("#include <stdint.h>\n")
	} else {
		buf.WriteString("#include <cstdint>\n")
	}

	buf.WriteString("\n")

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Struct definitions (reverse order - dependencies first)
	for i := len(info.Structs) - 1; i >= 0; i-- {
		s := info.Structs[i]
		if i < len(info.Structs)-1 {
			buf.WriteString("\n")
		}
		structCode, err := g.generateStruct(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(structCode)
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	buf.WriteString("\n#endif // JSON2CPP_TYPES_H\n")

	return buf.String(), nil
}

// generateStruct generates a single struct definition
func (g *AdapterGenerator) generateStruct(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Reset usedNames for each struct
	g.usedNames = make(map[string]int)

	buf.WriteString(fmt.Sprintf("struct %s {\n", s.Name))

	// Member variables
	for _, f := range s.Fields {
		member, err := g.generateMember(f)
		if err != nil {
			return "", err
		}
		buf.WriteString("    " + member + "\n")
	}

	// Default constructor for C++03 compatibility
	if g.legacyCpp {
		buf.WriteString("\n    ")
		buf.WriteString(s.Name)
		buf.WriteString("()")

		// Initialize POD types
		needsInit := false
		var initList bytes.Buffer
		for _, f := range s.Fields {
			if g.needsDefaultInit(f) {
				if needsInit {
					initList.WriteString(", ")
				} else {
					initList.WriteString(" : ")
					needsInit = true
				}
				fieldName := g.getFieldName(f.Name)
				initList.WriteString(fieldName)
				initList.WriteString("(")
				initList.WriteString(g.getDefaultInitValue(f))
				initList.WriteString(")")
			}
		}
		if needsInit {
			buf.WriteString(initList.String())
		}
		buf.WriteString(" {}\n")
	}

	buf.WriteString("};\n")

	return buf.String(), nil
}

// generateMember generates a member variable declaration
func (g *AdapterGenerator) generateMember(f *types.Field) (string, error) {
	memberType, err := g.getCppType(f)
	if err != nil {
		return "", err
	}

	fieldName := g.getFieldName(f.Name)
	return fmt.Sprintf("%s %s;", memberType, fieldName), nil
}

// getCppType returns the C++ type for a field
func (g *AdapterGenerator) getCppType(f *types.Field) (string, error) {
	switch f.Type {
	case types.JSONNull:
		// Null types are typically represented as bool or skipped
		return "bool", nil
	case types.JSONBool:
		return "bool", nil
	case types.JSONInt:
		return "int64_t", nil
	case types.JSONFloat:
		return "double", nil
	case types.JSONString:
		return "std::string", nil
	case types.JSONArray:
		if f.NestedType != nil {
			return fmt.Sprintf("std::vector<%s>", f.NestedType.Name), nil
		}
		switch f.ElemType {
		case types.JSONString:
			return "std::vector<std::string>", nil
		case types.JSONInt:
			return "std::vector<int64_t>", nil
		case types.JSONFloat:
			return "std::vector<double>", nil
		case types.JSONBool:
			return "std::vector<bool>", nil
		default:
			return "", fmt.Errorf("unsupported array element type: %v", f.ElemType)
		}
	case types.JSONObject:
		if f.NestedType != nil {
			return f.NestedType.Name, nil
		}
		return "", fmt.Errorf("anonymous objects not supported in adapter mode")
	default:
		return "", fmt.Errorf("unknown type: %v", f.Type)
	}
}

// needsDefaultInit checks if a field needs default initialization in C++03
func (g *AdapterGenerator) needsDefaultInit(f *types.Field) bool {
	return f.Type == types.JSONBool || f.Type == types.JSONInt || f.Type == types.JSONFloat
}

// getDefaultInitValue returns the default initialization value for a field
func (g *AdapterGenerator) getDefaultInitValue(f *types.Field) string {
	switch f.Type {
	case types.JSONBool:
		return "false"
	case types.JSONInt:
		return "0"
	case types.JSONFloat:
		return "0.0"
	default:
		return ""
	}
}

// getFieldName sanitizes and returns a C++ field name
func (g *AdapterGenerator) getFieldName(name string) string {
	sanitized := nameutil.SanitizeToCppIdentifier(name, g.useCamelCase, false)
	if _, ok := g.usedNames[sanitized]; !ok {
		g.usedNames[sanitized] = 0
	}
	return sanitized
}

// writeFile writes content to a file in the output directory
func (g *AdapterGenerator) writeFile(filename, content string) error {
	path := filepath.Join(g.outputDir, filename)
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer file.Close()

	if _, err := io.WriteString(file, content); err != nil {
		return fmt.Errorf("failed to write to file %s: %w", filename, err)
	}

	return nil
}

// generateSerializerHeader generates the serializer.h file
func (g *AdapterGenerator) generateSerializerHeader(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString("// Serialization functions (parser-independent)\n\n")
	buf.WriteString("#ifndef JSON2CPP_SERIALIZER_H\n")
	buf.WriteString("#define JSON2CPP_SERIALIZER_H\n\n")
	buf.WriteString("#include \"types.h\"\n")
	buf.WriteString("#include \"json_adapter.h\"\n\n")

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Function declarations
	for _, s := range info.Structs {
		buf.WriteString(fmt.Sprintf("// Deserialize %s from JSON\n", s.Name))
		buf.WriteString(fmt.Sprintf("void Deserialize%s(%s& obj, const json2cpp::IJsonReader& reader);\n\n", s.Name, s.Name))
		buf.WriteString(fmt.Sprintf("// Serialize %s to JSON\n", s.Name))
		buf.WriteString(fmt.Sprintf("void Serialize%s(const %s& obj, json2cpp::IJsonWriter& writer);\n\n", s.Name, s.Name))
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	buf.WriteString("\n#endif // JSON2CPP_SERIALIZER_H\n")

	return buf.String(), nil
}

// generateSerializerImpl generates the serializer.cpp file
func (g *AdapterGenerator) generateSerializerImpl(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString("// Serialization implementation\n\n")
	buf.WriteString("#include \"serializer.h\"\n\n")

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Generate deserialize and serialize functions for each struct
	for i, s := range info.Structs {
		if i > 0 {
			buf.WriteString("\n")
		}

		// Reset usedNames for each struct
		g.usedNames = make(map[string]int)

		// Deserialize function
		deserializeCode, err := g.generateDeserializeFunction(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(deserializeCode)
		buf.WriteString("\n\n")

		// Serialize function
		serializeCode, err := g.generateSerializeFunction(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(serializeCode)
		buf.WriteString("\n")
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	return buf.String(), nil
}

// generateDeserializeFunction generates a deserialize function for a struct
func (g *AdapterGenerator) generateDeserializeFunction(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("void Deserialize%s(%s& obj, const json2cpp::IJsonReader& reader) {\n", s.Name, s.Name))

	for _, f := range s.Fields {
		code, err := g.generateDeserializeField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateDeserializeField generates deserialization code for a single field
func (g *AdapterGenerator) generateDeserializeField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		// Skip null fields
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    obj.%s = reader.GetBool(\"%s\");\n", fieldName, jsonName))

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    obj.%s = reader.GetInt64(\"%s\");\n", fieldName, jsonName))

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    obj.%s = reader.GetDouble(\"%s\");\n", fieldName, jsonName))

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    obj.%s = reader.GetString(\"%s\");\n", fieldName, jsonName))

	case types.JSONArray:
		if f.NestedType != nil {
			// Array of nested objects
			buf.WriteString(fmt.Sprintf("    if (reader.IsArray(\"%s\")) {\n", jsonName))
			buf.WriteString(fmt.Sprintf("        std::unique_ptr<json2cpp::IJsonReader> arr = reader.GetArray(\"%s\");\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (size_t i = 0; i < arr->GetArraySize(); ++i) {\n")
			buf.WriteString("            std::unique_ptr<json2cpp::IJsonReader> elem = arr->GetElement(i);\n")
			buf.WriteString(fmt.Sprintf("            %s item;\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            Deserialize%s(item, *elem);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            obj.%s.push_back(item);\n", fieldName))
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		} else {
			// Array of primitives
			buf.WriteString(fmt.Sprintf("    if (reader.IsArray(\"%s\")) {\n", jsonName))
			buf.WriteString(fmt.Sprintf("        std::unique_ptr<json2cpp::IJsonReader> arr = reader.GetArray(\"%s\");\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (size_t i = 0; i < arr->GetArraySize(); ++i) {\n")
			buf.WriteString("            std::unique_ptr<json2cpp::IJsonReader> elem = arr->GetElement(i);\n")

			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf("            obj.%s.push_back(elem->GetRootString());\n", fieldName))
			case types.JSONInt:
				buf.WriteString(fmt.Sprintf("            obj.%s.push_back(elem->GetRootInt64());\n", fieldName))
			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf("            obj.%s.push_back(elem->GetRootDouble());\n", fieldName))
			case types.JSONBool:
				buf.WriteString(fmt.Sprintf("            obj.%s.push_back(elem->GetRootBool());\n", fieldName))
			}

			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (reader.IsObject(\"%s\")) {\n", jsonName))
			buf.WriteString(fmt.Sprintf("        std::unique_ptr<json2cpp::IJsonReader> nested = reader.GetObject(\"%s\");\n", jsonName))
			buf.WriteString(fmt.Sprintf("        Deserialize%s(obj.%s, *nested);\n", f.NestedType.Name, fieldName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type in deserialize: %v", f.Type)
	}

	return buf.String(), nil
}

// generateSerializeFunction generates a serialize function for a struct
func (g *AdapterGenerator) generateSerializeFunction(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("void Serialize%s(const %s& obj, json2cpp::IJsonWriter& writer) {\n", s.Name, s.Name))

	for _, f := range s.Fields {
		code, err := g.generateSerializeField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateSerializeField generates serialization code for a single field
func (g *AdapterGenerator) generateSerializeField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		// Skip null fields
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    writer.SetBool(\"%s\", obj.%s);\n", jsonName, fieldName))

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    writer.SetInt64(\"%s\", obj.%s);\n", jsonName, fieldName))

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    writer.SetDouble(\"%s\", obj.%s);\n", jsonName, fieldName))

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    writer.SetString(\"%s\", obj.%s);\n", jsonName, fieldName))

	case types.JSONArray:
		buf.WriteString(fmt.Sprintf("    {\n"))
		buf.WriteString(fmt.Sprintf("        std::unique_ptr<json2cpp::IJsonWriter> arr = writer.CreateArray(\"%s\");\n", jsonName))

		if f.NestedType != nil {
			// Array of nested objects
			buf.WriteString(fmt.Sprintf("        for (size_t i = 0; i < obj.%s.size(); ++i) {\n", fieldName))
			buf.WriteString("            std::unique_ptr<json2cpp::IJsonWriter> item = arr->PushObject();\n")
			buf.WriteString(fmt.Sprintf("            Serialize%s(obj.%s[i], *item);\n", f.NestedType.Name, fieldName))
			buf.WriteString("        }\n")
		} else {
			// Array of primitives
			buf.WriteString(fmt.Sprintf("        for (size_t i = 0; i < obj.%s.size(); ++i) {\n", fieldName))

			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf("            arr->PushString(obj.%s[i]);\n", fieldName))
			case types.JSONInt:
				buf.WriteString(fmt.Sprintf("            arr->PushInt64(obj.%s[i]);\n", fieldName))
			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf("            arr->PushDouble(obj.%s[i]);\n", fieldName))
			case types.JSONBool:
				buf.WriteString(fmt.Sprintf("            arr->PushBool(obj.%s[i]);\n", fieldName))
			}

			buf.WriteString("        }\n")
		}

		buf.WriteString("    }\n")

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    {\n"))
			buf.WriteString(fmt.Sprintf("        std::unique_ptr<json2cpp::IJsonWriter> nested = writer.CreateObject(\"%s\");\n", jsonName))
			buf.WriteString(fmt.Sprintf("        Serialize%s(obj.%s, *nested);\n", f.NestedType.Name, fieldName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type in serialize: %v", f.Type)
	}

	return buf.String(), nil
}

// Generate implements CodeGenerator interface (legacy support)
func (g *AdapterGenerator) Generate(info *types.TypeInfo) (string, error) {
	// This is kept for interface compatibility but not used in adapter mode
	return "", fmt.Errorf("adapter generator must use GenerateFiles() instead of Generate()")
}
