package codegen

import (
	"bytes"
	"fmt"
	"io"
	"json2cpp/internal/nameutil"
	"json2cpp/internal/types"
	"os"
	"path/filepath"
)

// AdapterGenerator generates parser-agnostic C++ code with separate serializers
type AdapterGenerator struct {
	parser       ParserType
	legacyCpp    bool
	namespace    string
	useCamelCase bool
	optionalNull bool
	outputDir    string
	usedNames    map[string]int
}

// NewAdapterGenerator creates a new adapter-based code generator
func NewAdapterGenerator(cfg Config, outputDir string) *AdapterGenerator {
	parser := cfg.Parser
	if parser == "" {
		parser = ParserRapidJSON
	}
	return &AdapterGenerator{
		parser:       parser,
		legacyCpp:    cfg.LegacyCPP,
		namespace:    cfg.Namespace,
		useCamelCase: cfg.CamelCase,
		optionalNull: cfg.OptionalNull,
		outputDir:    outputDir,
		usedNames:    make(map[string]int),
	}
}

// GenerateFiles generates all necessary files (types.h and parser-specific serializer)
func (g *AdapterGenerator) GenerateFiles(info *types.TypeInfo) error {
	// Sort structs by dependencies
	types.SortStructs(info.Structs)

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate types.h (parser-independent)
	typesContent, err := g.generateTypes(info)
	if err != nil {
		return fmt.Errorf("failed to generate types.h: %w", err)
	}
	if err := g.writeFile("types.h", typesContent); err != nil {
		return err
	}

	// Generate parser-specific serializer header
	serializerHeaderName := fmt.Sprintf("serializer_%s.h", g.parser)
	serializerHeader, err := g.generateSerializerHeader(info)
	if err != nil {
		return fmt.Errorf("failed to generate %s: %w", serializerHeaderName, err)
	}
	if err := g.writeFile(serializerHeaderName, serializerHeader); err != nil {
		return err
	}

	// Generate parser-specific serializer implementation
	serializerImplName := fmt.Sprintf("serializer_%s.cpp", g.parser)
	serializerImpl, err := g.generateSerializerImpl(info)
	if err != nil {
		return fmt.Errorf("failed to generate %s: %w", serializerImplName, err)
	}
	if err := g.writeFile(serializerImplName, serializerImpl); err != nil {
		return err
	}

	return nil
}


// generateTypes generates the types.h file with pure data structures
func (g *AdapterGenerator) generateTypes(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header comment and guard
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString("// Pure data structures (parser-independent)\n\n")
	buf.WriteString("#ifndef JSON2CPP_TYPES_H\n")
	buf.WriteString("#define JSON2CPP_TYPES_H\n\n")
	buf.WriteString("#include <string>\n")
	buf.WriteString("#include <vector>\n")

	// Include int64_t
	if g.legacyCpp {
		buf.WriteString("#include <stdint.h>\n")
	} else {
		buf.WriteString("#include <cstdint>\n")
	}

	buf.WriteString("\n")

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Struct definitions (reverse order - dependencies first)
	for i := len(info.Structs) - 1; i >= 0; i-- {
		s := info.Structs[i]
		if i < len(info.Structs)-1 {
			buf.WriteString("\n")
		}
		structCode, err := g.generateStruct(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(structCode)
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	buf.WriteString("\n#endif // JSON2CPP_TYPES_H\n")

	return buf.String(), nil
}

// generateStruct generates a single struct definition
func (g *AdapterGenerator) generateStruct(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Reset usedNames for each struct
	g.usedNames = make(map[string]int)

	buf.WriteString(fmt.Sprintf("struct %s {\n", s.Name))

	// Member variables
	for _, f := range s.Fields {
		member, err := g.generateMember(f)
		if err != nil {
			return "", err
		}
		buf.WriteString("    " + member + "\n")
	}

	// Default constructor for C++03 compatibility
	if g.legacyCpp {
		buf.WriteString("\n    ")
		buf.WriteString(s.Name)
		buf.WriteString("()")

		// Initialize POD types
		needsInit := false
		var initList bytes.Buffer
		for _, f := range s.Fields {
			if g.needsDefaultInit(f) {
				if needsInit {
					initList.WriteString(", ")
				} else {
					initList.WriteString(" : ")
					needsInit = true
				}
				fieldName := g.getFieldName(f.Name)
				initList.WriteString(fieldName)
				initList.WriteString("(")
				initList.WriteString(g.getDefaultInitValue(f))
				initList.WriteString(")")
			}
		}
		if needsInit {
			buf.WriteString(initList.String())
		}
		buf.WriteString(" {}\n")
	}

	buf.WriteString("};\n")

	return buf.String(), nil
}

// generateMember generates a member variable declaration
func (g *AdapterGenerator) generateMember(f *types.Field) (string, error) {
	memberType, err := g.getCppType(f)
	if err != nil {
		return "", err
	}

	fieldName := g.getFieldName(f.Name)
	return fmt.Sprintf("%s %s;", memberType, fieldName), nil
}

// getCppType returns the C++ type for a field
func (g *AdapterGenerator) getCppType(f *types.Field) (string, error) {
	switch f.Type {
	case types.JSONNull:
		// Null types are typically represented as bool or skipped
		return "bool", nil
	case types.JSONBool:
		return "bool", nil
	case types.JSONInt:
		return "int64_t", nil
	case types.JSONFloat:
		return "double", nil
	case types.JSONString:
		return "std::string", nil
	case types.JSONArray:
		if f.NestedType != nil {
			return fmt.Sprintf("std::vector<%s>", f.NestedType.Name), nil
		}
		switch f.ElemType {
		case types.JSONString:
			return "std::vector<std::string>", nil
		case types.JSONInt:
			return "std::vector<int64_t>", nil
		case types.JSONFloat:
			return "std::vector<double>", nil
		case types.JSONBool:
			return "std::vector<bool>", nil
		default:
			return "", fmt.Errorf("unsupported array element type: %v", f.ElemType)
		}
	case types.JSONObject:
		if f.NestedType != nil {
			return f.NestedType.Name, nil
		}
		return "", fmt.Errorf("anonymous objects not supported in adapter mode")
	default:
		return "", fmt.Errorf("unknown type: %v", f.Type)
	}
}

// needsDefaultInit checks if a field needs default initialization in C++03
func (g *AdapterGenerator) needsDefaultInit(f *types.Field) bool {
	return f.Type == types.JSONBool || f.Type == types.JSONInt || f.Type == types.JSONFloat
}

// getDefaultInitValue returns the default initialization value for a field
func (g *AdapterGenerator) getDefaultInitValue(f *types.Field) string {
	switch f.Type {
	case types.JSONBool:
		return "false"
	case types.JSONInt:
		return "0"
	case types.JSONFloat:
		return "0.0"
	default:
		return ""
	}
}

// getFieldName sanitizes and returns a C++ field name
func (g *AdapterGenerator) getFieldName(name string) string {
	sanitized := nameutil.SanitizeToCppIdentifier(name, g.useCamelCase, false)
	if _, ok := g.usedNames[sanitized]; !ok {
		g.usedNames[sanitized] = 0
	}
	return sanitized
}

// writeFile writes content to a file in the output directory
func (g *AdapterGenerator) writeFile(filename, content string) error {
	path := filepath.Join(g.outputDir, filename)
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer file.Close()

	if _, err := io.WriteString(file, content); err != nil {
		return fmt.Errorf("failed to write to file %s: %w", filename, err)
	}

	return nil
}

// generateSerializerHeader generates the parser-specific serializer header file
func (g *AdapterGenerator) generateSerializerHeader(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header guard
	guardName := fmt.Sprintf("JSON2CPP_SERIALIZER_%s_H", g.parser)
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString(fmt.Sprintf("// %s serialization functions\n\n", g.parser))
	buf.WriteString(fmt.Sprintf("#ifndef %s\n", guardName))
	buf.WriteString(fmt.Sprintf("#define %s\n\n", guardName))
	buf.WriteString("#include \"types.h\"\n")

	// Parser-specific includes
	switch g.parser {
	case ParserRapidJSON:
		buf.WriteString("#include <rapidjson/document.h>\n")
		buf.WriteString("#include <rapidjson/writer.h>\n")
		buf.WriteString("#include <rapidjson/stringbuffer.h>\n")
	case ParserNlohmann:
		buf.WriteString("#include <nlohmann/json.hpp>\n")
	case ParserJsonCpp:
		buf.WriteString("#include <json/json.h>\n")
	}
	buf.WriteString("\n")

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Function declarations
	for _, s := range info.Structs {
		buf.WriteString(fmt.Sprintf("// Deserialize %s from JSON\n", s.Name))
		buf.WriteString(g.generateDeserializeFunctionDecl(s))
		buf.WriteString("\n\n")
		buf.WriteString(fmt.Sprintf("// Serialize %s to JSON\n", s.Name))
		buf.WriteString(g.generateSerializeFunctionDecl(s))
		buf.WriteString("\n\n")
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	buf.WriteString(fmt.Sprintf("\n#endif // %s\n", guardName))

	return buf.String(), nil
}

// generateDeserializeFunctionDecl generates the deserialize function declaration
func (g *AdapterGenerator) generateDeserializeFunctionDecl(s *types.Struct) string {
	switch g.parser {
	case ParserRapidJSON:
		return fmt.Sprintf("void Deserialize%s(%s& obj, const rapidjson::Value& json);", s.Name, s.Name)
	case ParserNlohmann:
		return fmt.Sprintf("void Deserialize%s(%s& obj, const nlohmann::json& json);", s.Name, s.Name)
	case ParserJsonCpp:
		return fmt.Sprintf("void Deserialize%s(%s& obj, const Json::Value& json);", s.Name, s.Name)
	default:
		return ""
	}
}

// generateSerializeFunctionDecl generates the serialize function declaration
func (g *AdapterGenerator) generateSerializeFunctionDecl(s *types.Struct) string {
	switch g.parser {
	case ParserRapidJSON:
		return fmt.Sprintf("void Serialize%s(const %s& obj, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator);", s.Name, s.Name)
	case ParserNlohmann:
		return fmt.Sprintf("void Serialize%s(const %s& obj, nlohmann::json& json);", s.Name, s.Name)
	case ParserJsonCpp:
		return fmt.Sprintf("void Serialize%s(const %s& obj, Json::Value& json);", s.Name, s.Name)
	default:
		return ""
	}
}

// generateSerializerImpl generates the parser-specific serializer implementation file
func (g *AdapterGenerator) generateSerializerImpl(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("// Auto-generated by json2cpp\n")
	buf.WriteString(fmt.Sprintf("// %s serialization implementation\n\n", g.parser))
	buf.WriteString(fmt.Sprintf("#include \"serializer_%s.h\"\n\n", g.parser))

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Generate deserialize and serialize functions for each struct
	for i, s := range info.Structs {
		if i > 0 {
			buf.WriteString("\n")
		}

		// Reset usedNames for each struct
		g.usedNames = make(map[string]int)

		// Deserialize function
		deserializeCode, err := g.generateDeserializeFunction(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(deserializeCode)
		buf.WriteString("\n\n")

		// Serialize function
		serializeCode, err := g.generateSerializeFunction(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(serializeCode)
		buf.WriteString("\n")
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n} // namespace ")
		buf.WriteString(g.namespace)
		buf.WriteString("\n")
	}

	return buf.String(), nil
}

// generateDeserializeFunction generates a deserialize function for a struct
func (g *AdapterGenerator) generateDeserializeFunction(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Function signature based on parser type
	switch g.parser {
	case ParserRapidJSON:
		buf.WriteString(fmt.Sprintf("void Deserialize%s(%s& obj, const rapidjson::Value& json) {\n", s.Name, s.Name))
	case ParserNlohmann:
		buf.WriteString(fmt.Sprintf("void Deserialize%s(%s& obj, const nlohmann::json& json) {\n", s.Name, s.Name))
	case ParserJsonCpp:
		buf.WriteString(fmt.Sprintf("void Deserialize%s(%s& obj, const Json::Value& json) {\n", s.Name, s.Name))
	}

	for _, f := range s.Fields {
		code, err := g.generateDeserializeField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateDeserializeField generates parser-specific deserialization code for a single field
func (g *AdapterGenerator) generateDeserializeField(f *types.Field) (string, error) {
	switch g.parser {
	case ParserRapidJSON:
		return g.generateDeserializeFieldRapidJSON(f)
	case ParserNlohmann:
		return g.generateDeserializeFieldNlohmann(f)
	case ParserJsonCpp:
		return g.generateDeserializeFieldJsonCpp(f)
	default:
		return "", fmt.Errorf("unsupported parser: %v", g.parser)
	}
}

// generateDeserializeFieldRapidJSON generates RapidJSON deserialization code
func (g *AdapterGenerator) generateDeserializeFieldRapidJSON(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsBool()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].GetBool();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\")) {\n", jsonName))
		buf.WriteString(fmt.Sprintf("        if (json[\"%s\"].IsInt64()) {\n", jsonName))
		buf.WriteString(fmt.Sprintf("            obj.%s = json[\"%s\"].GetInt64();\n", fieldName, jsonName))
		buf.WriteString(fmt.Sprintf("        } else if (json[\"%s\"].IsInt()) {\n", jsonName))
		buf.WriteString(fmt.Sprintf("            obj.%s = static_cast<int64_t>(json[\"%s\"].GetInt());\n", fieldName, jsonName))
		buf.WriteString("        }\n")
		buf.WriteString("    }\n")

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsDouble()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].GetDouble();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsString()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].GetString();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsArray()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        const rapidjson::Value& arr = json[\"%s\"];\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {\n")
			buf.WriteString(fmt.Sprintf("            %s item;\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            Deserialize%s(item, arr[i]);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            obj.%s.push_back(item);\n", fieldName))
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		} else {
			buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsArray()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        const rapidjson::Value& arr = json[\"%s\"];\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {\n")
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString("            if (arr[i].IsString()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].GetString());\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONInt:
				buf.WriteString("            if (arr[i].IsInt64()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].GetInt64());\n", fieldName))
				buf.WriteString("            } else if (arr[i].IsInt()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(static_cast<int64_t>(arr[i].GetInt()));\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONFloat:
				buf.WriteString("            if (arr[i].IsDouble()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].GetDouble());\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONBool:
				buf.WriteString("            if (arr[i].IsBool()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].GetBool());\n", fieldName))
				buf.WriteString("            }\n")
			}
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.HasMember(\"%s\") && json[\"%s\"].IsObject()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        Deserialize%s(obj.%s, json[\"%s\"]);\n", f.NestedType.Name, fieldName, jsonName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// generateDeserializeFieldNlohmann generates nlohmann/json deserialization code
func (g *AdapterGenerator) generateDeserializeFieldNlohmann(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_boolean()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].get<bool>();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_number_integer()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].get<int64_t>();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_number()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].get<double>();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_string()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].get<std::string>();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_array()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString(fmt.Sprintf("        for (const auto& elem : json[\"%s\"]) {\n", jsonName))
			buf.WriteString(fmt.Sprintf("            %s item;\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            Deserialize%s(item, elem);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            obj.%s.push_back(item);\n", fieldName))
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		} else {
			buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_array()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].get<", fieldName, jsonName))
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString("std::vector<std::string>")
			case types.JSONInt:
				buf.WriteString("std::vector<int64_t>")
			case types.JSONFloat:
				buf.WriteString("std::vector<double>")
			case types.JSONBool:
				buf.WriteString("std::vector<bool>")
			}
			buf.WriteString(">();\n")
			buf.WriteString("    }\n")
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.contains(\"%s\") && json[\"%s\"].is_object()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        Deserialize%s(obj.%s, json[\"%s\"]);\n", f.NestedType.Name, fieldName, jsonName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// generateDeserializeFieldJsonCpp generates JsonCpp deserialization code
func (g *AdapterGenerator) generateDeserializeFieldJsonCpp(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isBool()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].asBool();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isInt64()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].asInt64();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isDouble()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].asDouble();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isString()) {\n", jsonName, jsonName))
		buf.WriteString(fmt.Sprintf("        obj.%s = json[\"%s\"].asString();\n", fieldName, jsonName))
		buf.WriteString("    }\n")

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isArray()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        const Json::Value& arr = json[\"%s\"];\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {\n")
			buf.WriteString(fmt.Sprintf("            %s item;\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            Deserialize%s(item, arr[i]);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("            obj.%s.push_back(item);\n", fieldName))
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		} else {
			buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isArray()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        const Json::Value& arr = json[\"%s\"];\n", jsonName))
			buf.WriteString(fmt.Sprintf("        obj.%s.clear();\n", fieldName))
			buf.WriteString("        for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {\n")
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString("            if (arr[i].isString()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].asString());\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONInt:
				buf.WriteString("            if (arr[i].isInt64()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].asInt64());\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONFloat:
				buf.WriteString("            if (arr[i].isDouble()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].asDouble());\n", fieldName))
				buf.WriteString("            }\n")
			case types.JSONBool:
				buf.WriteString("            if (arr[i].isBool()) {\n")
				buf.WriteString(fmt.Sprintf("                obj.%s.push_back(arr[i].asBool());\n", fieldName))
				buf.WriteString("            }\n")
			}
			buf.WriteString("        }\n")
			buf.WriteString("    }\n")
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    if (json.isMember(\"%s\") && json[\"%s\"].isObject()) {\n", jsonName, jsonName))
			buf.WriteString(fmt.Sprintf("        Deserialize%s(obj.%s, json[\"%s\"]);\n", f.NestedType.Name, fieldName, jsonName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// generateSerializeFunction generates a serialize function for a struct
func (g *AdapterGenerator) generateSerializeFunction(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Function signature based on parser type
	switch g.parser {
	case ParserRapidJSON:
		buf.WriteString(fmt.Sprintf("void Serialize%s(const %s& obj, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator) {\n", s.Name, s.Name))
	case ParserNlohmann:
		buf.WriteString(fmt.Sprintf("void Serialize%s(const %s& obj, nlohmann::json& json) {\n", s.Name, s.Name))
	case ParserJsonCpp:
		buf.WriteString(fmt.Sprintf("void Serialize%s(const %s& obj, Json::Value& json) {\n", s.Name, s.Name))
	}

	for _, f := range s.Fields {
		code, err := g.generateSerializeField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateSerializeField generates parser-specific serialization code for a single field
func (g *AdapterGenerator) generateSerializeField(f *types.Field) (string, error) {
	switch g.parser {
	case ParserRapidJSON:
		return g.generateSerializeFieldRapidJSON(f)
	case ParserNlohmann:
		return g.generateSerializeFieldNlohmann(f)
	case ParserJsonCpp:
		return g.generateSerializeFieldJsonCpp(f)
	default:
		return "", fmt.Errorf("unsupported parser: %v", g.parser)
	}
}

// generateSerializeFieldRapidJSON generates RapidJSON serialization code
func (g *AdapterGenerator) generateSerializeFieldRapidJSON(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool:
		buf.WriteString(fmt.Sprintf("    json.AddMember(\"%s\", obj.%s, allocator);\n", jsonName, fieldName))

	case types.JSONInt:
		buf.WriteString(fmt.Sprintf("    json.AddMember(\"%s\", obj.%s, allocator);\n", jsonName, fieldName))

	case types.JSONFloat:
		buf.WriteString(fmt.Sprintf("    json.AddMember(\"%s\", obj.%s, allocator);\n", jsonName, fieldName))

	case types.JSONString:
		buf.WriteString(fmt.Sprintf("    json.AddMember(\"%s\", rapidjson::Value(obj.%s.c_str(), allocator), allocator);\n", jsonName, fieldName))

	case types.JSONArray:
		buf.WriteString("    {\n")
		buf.WriteString("        rapidjson::Value arr(rapidjson::kArrayType);\n")
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("        for (const auto& item : obj.%s) {\n", fieldName))
			buf.WriteString("            rapidjson::Value elem(rapidjson::kObjectType);\n")
			buf.WriteString(fmt.Sprintf("            Serialize%s(item, elem, allocator);\n", f.NestedType.Name))
			buf.WriteString("            arr.PushBack(elem, allocator);\n")
			buf.WriteString("        }\n")
		} else {
			buf.WriteString(fmt.Sprintf("        for (const auto& item : obj.%s) {\n", fieldName))
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString("            arr.PushBack(rapidjson::Value(item.c_str(), allocator), allocator);\n")
			case types.JSONInt, types.JSONFloat, types.JSONBool:
				buf.WriteString("            arr.PushBack(item, allocator);\n")
			}
			buf.WriteString("        }\n")
		}
		buf.WriteString(fmt.Sprintf("        json.AddMember(\"%s\", arr, allocator);\n", jsonName))
		buf.WriteString("    }\n")

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString("    {\n")
			buf.WriteString("        rapidjson::Value nested(rapidjson::kObjectType);\n")
			buf.WriteString(fmt.Sprintf("        Serialize%s(obj.%s, nested, allocator);\n", f.NestedType.Name, fieldName))
			buf.WriteString(fmt.Sprintf("        json.AddMember(\"%s\", nested, allocator);\n", jsonName))
			buf.WriteString("    }\n")
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// generateSerializeFieldNlohmann generates nlohmann/json serialization code
func (g *AdapterGenerator) generateSerializeFieldNlohmann(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool, types.JSONInt, types.JSONFloat, types.JSONString:
		buf.WriteString(fmt.Sprintf("    json[\"%s\"] = obj.%s;\n", jsonName, fieldName))

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    json[\"%s\"] = nlohmann::json::array();\n", jsonName))
			buf.WriteString(fmt.Sprintf("    for (const auto& item : obj.%s) {\n", fieldName))
			buf.WriteString("        nlohmann::json elem;\n")
			buf.WriteString(fmt.Sprintf("        Serialize%s(item, elem);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("        json[\"%s\"].push_back(elem);\n", jsonName))
			buf.WriteString("    }\n")
		} else {
			buf.WriteString(fmt.Sprintf("    json[\"%s\"] = obj.%s;\n", jsonName, fieldName))
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    json[\"%s\"] = nlohmann::json::object();\n", jsonName))
			buf.WriteString(fmt.Sprintf("    Serialize%s(obj.%s, json[\"%s\"]);\n", f.NestedType.Name, fieldName, jsonName))
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// generateSerializeFieldJsonCpp generates JsonCpp serialization code
func (g *AdapterGenerator) generateSerializeFieldJsonCpp(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		return "", nil

	case types.JSONBool, types.JSONInt, types.JSONFloat, types.JSONString:
		buf.WriteString(fmt.Sprintf("    json[\"%s\"] = obj.%s;\n", jsonName, fieldName))

	case types.JSONArray:
		buf.WriteString(fmt.Sprintf("    json[\"%s\"] = Json::Value(Json::arrayValue);\n", jsonName))
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    for (const auto& item : obj.%s) {\n", fieldName))
			buf.WriteString("        Json::Value elem(Json::objectValue);\n")
			buf.WriteString(fmt.Sprintf("        Serialize%s(item, elem);\n", f.NestedType.Name))
			buf.WriteString(fmt.Sprintf("        json[\"%s\"].append(elem);\n", jsonName))
			buf.WriteString("    }\n")
		} else {
			buf.WriteString(fmt.Sprintf("    for (const auto& item : obj.%s) {\n", fieldName))
			buf.WriteString(fmt.Sprintf("        json[\"%s\"].append(item);\n", jsonName))
			buf.WriteString("    }\n")
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf("    json[\"%s\"] = Json::Value(Json::objectValue);\n", jsonName))
			buf.WriteString(fmt.Sprintf("    Serialize%s(obj.%s, json[\"%s\"]);\n", f.NestedType.Name, fieldName, jsonName))
		}

	default:
		return "", fmt.Errorf("unknown field type: %v", f.Type)
	}

	return buf.String(), nil
}

// Generate implements CodeGenerator interface (legacy support)
func (g *AdapterGenerator) Generate(info *types.TypeInfo) (string, error) {
	// This is kept for interface compatibility but not used in adapter mode
	return "", fmt.Errorf("adapter generator must use GenerateFiles() instead of Generate()")
}
