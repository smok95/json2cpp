package codegen

import (
	"bytes"
	"fmt"
	"json2cpp/internal/nameutil"
	"json2cpp/internal/types"
)

// JsonCppGenerator generates C++ code using JsonCpp library
type JsonCppGenerator struct {
	legacyCpp    bool
	namespace    string
	useCamelCase bool
	optionalNull bool
	stringRef    bool
	usedNames    map[string]int
}

// NewJsonCppGenerator creates a new JsonCpp code generator
func NewJsonCppGenerator(cfg Config) *JsonCppGenerator {
	return &JsonCppGenerator{
		legacyCpp:    cfg.LegacyCPP,
		namespace:    cfg.Namespace,
		useCamelCase: cfg.CamelCase,
		optionalNull: cfg.OptionalNull,
		stringRef:    cfg.StringRef,
		usedNames:    make(map[string]int),
	}
}

func (g *JsonCppGenerator) Generate(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header guard and includes
	buf.WriteString(g.generateHeader())
	buf.WriteString("\n\n")

	// Optional type definition (for legacy C++)
	if g.legacyCpp && g.optionalNull {
		buf.WriteString(g.generateOptionalType())
		buf.WriteString("\n\n")
	}

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Struct definitions (sorted by dependencies)
	types.SortStructs(info.Structs)
	for i, s := range info.Structs {
		if i > 0 {
			buf.WriteString("\n\n")
		}
		str, err := g.generateStruct(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(str)
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n\n} // namespace ")
		buf.WriteString(g.namespace)
	}

	return buf.String(), nil
}

func (g *JsonCppGenerator) generateHeader() string {
	return `// Auto-generated by json2cpp
// DO NOT EDIT
// Parser: JsonCpp

#pragma once

#include <string>
#include <vector>
#include <json/json.h>`
}

func (g *JsonCppGenerator) generateOptionalType() string {
	return `// pre-C++11 compatible Optional implementation
template<typename T>
struct Optional {
    bool has;
    T value;

    Optional() : has(false) {}
    Optional(const T& v) : has(true), value(v) {}

    bool IsValid() const { return has; }
    const T& Get() const { return value; }
    T& Get() { return value; }
    void Set(const T& v) { has = true; value = v; }
    void Clear() { has = false; }
};

typedef Optional<int> OptionalInt;
typedef Optional<int64_t> OptionalInt64;
typedef Optional<double> OptionalDouble;
typedef Optional<bool> OptionalBool;
typedef Optional<std::string> OptionalString;`
}

func (g *JsonCppGenerator) generateStruct(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Reset usedNames for each struct
	g.usedNames = make(map[string]int)

	// Struct definition
	buf.WriteString(fmt.Sprintf("struct %s {\n", s.Name))

	// Member variables
	for _, f := range s.Fields {
		member, err := g.generateMember(f)
		if err != nil {
			return "", err
		}
		buf.WriteString("    " + member + "\n")
	}

	// FromJson / ToJson methods
	fromJson, err := g.generateFromJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n")
	buf.WriteString(fromJson)

	toJson, err := g.generateToJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n\n")
	buf.WriteString(toJson)

	buf.WriteString("\n};")

	return buf.String(), nil
}

func (g *JsonCppGenerator) generateMember(f *types.Field) (string, error) {
	var memberType string

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			memberType = "Optional<bool>"
		} else {
			memberType = "bool"
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalBool"
		} else {
			memberType = "bool"
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalInt64"
		} else {
			memberType = "int64_t"
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalDouble"
		} else {
			memberType = "double"
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalString"
		} else if g.stringRef {
			memberType = "const std::string&"
		} else {
			memberType = "std::string"
		}

	case types.JSONArray:
		if f.NestedType != nil {
			memberType = fmt.Sprintf("std::vector<%s>", f.NestedType.Name)
		} else {
			switch f.ElemType {
			case types.JSONString:
				memberType = "std::vector<std::string>"
			case types.JSONInt:
				memberType = "std::vector<int64_t>"
			case types.JSONFloat:
				memberType = "std::vector<double>"
			case types.JSONBool:
				memberType = "std::vector<bool>"
			default:
				memberType = "std::vector<Json::Value>"
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			memberType = f.NestedType.Name
		} else {
			memberType = "Json::Value"
		}

	default:
		return "", fmt.Errorf("unknown type: %v", f.Type)
	}

	fieldName := g.getFieldName(f.Name)
	return fmt.Sprintf("%s %s;", memberType, fieldName), nil
}

func (g *JsonCppGenerator) generateFromJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("    void FromJson(const Json::Value& v) {\n")

	for _, f := range s.Fields {
		code, err := g.generateFromJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *JsonCppGenerator) generateFromJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isNull()) {
            %s.Clear();
        } else {
            %s.has = false;
        }
`, jsonName, jsonName, fieldName, fieldName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isBool()) {
            %s.Set(v["%s"].asBool());
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isBool()) {
            %s = v["%s"].asBool();
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isInt64()) {
            %s.Set(v["%s"].asInt64());
        } else if (v.isMember("%s") && v["%s"].isInt()) {
            %s.Set(static_cast<int64_t>(v["%s"].asInt()));
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isInt64()) {
            %s = v["%s"].asInt64();
        } else if (v.isMember("%s") && v["%s"].isInt()) {
            %s = static_cast<int64_t>(v["%s"].asInt());
        }
`, jsonName, jsonName, fieldName, jsonName, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isDouble()) {
            %s.Set(v["%s"].asDouble());
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isDouble()) {
            %s = v["%s"].asDouble();
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isString()) {
            %s.Set(v["%s"].asString());
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isString()) {
            %s = v["%s"].asString();
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            const Json::Value& arr = v["%s"];
            %s.clear();
            for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {
                %s item;
                item.FromJson(arr[i]);
                %s.push_back(item);
            }
        }
`, jsonName, jsonName, jsonName, fieldName, f.NestedType.Name, fieldName))
		} else {
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            const Json::Value& arr = v["%s"];
            %s.clear();
            for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {
                if (arr[i].isString()) {
                    %s.push_back(arr[i].asString());
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName))

			case types.JSONInt:
				buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            const Json::Value& arr = v["%s"];
            %s.clear();
            for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {
                if (arr[i].isInt64()) {
                    %s.push_back(arr[i].asInt64());
                } else if (arr[i].isInt()) {
                    %s.push_back(static_cast<int64_t>(arr[i].asInt()));
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName, fieldName))

			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            const Json::Value& arr = v["%s"];
            %s.clear();
            for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {
                if (arr[i].isDouble()) {
                    %s.push_back(arr[i].asDouble());
                } else if (arr[i].isNumeric()) {
                    %s.push_back(static_cast<double>(arr[i].asDouble()));
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName, fieldName))

			case types.JSONBool:
				buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            const Json::Value& arr = v["%s"];
            %s.clear();
            for (Json::ArrayIndex i = 0; i < arr.size(); ++i) {
                if (arr[i].isBool()) {
                    %s.push_back(arr[i].asBool());
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName))

			default:
				buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isArray()) {
            %s = v["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isObject()) {
            %s.FromJson(v["%s"]);
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.isMember("%s") && v["%s"].isObject()) {
            %s = v["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	default:
		return "", fmt.Errorf("unknown type in FromJson: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *JsonCppGenerator) generateToJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("    void ToJson(Json::Value& v) const {\n")

	for _, f := range s.Fields {
		code, err := g.generateToJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *JsonCppGenerator) generateToJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v["%s"] = Json::Value::null;
        }
`, fieldName, jsonName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v["%s"] = %s.Get();
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v["%s"] = Json::Value::Int64(%s.Get());
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value::Int64(%s);
`, jsonName, fieldName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v["%s"] = %s.Get();
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v["%s"] = %s.Get();
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value(Json::arrayValue);
        for (std::vector<%s>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
            Json::Value item_val;
            it->ToJson(item_val);
            v["%s"].append(item_val);
        }
`, jsonName, f.NestedType.Name, fieldName, fieldName, jsonName))
		} else {
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value(Json::arrayValue);
        for (std::vector<std::string>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
            v["%s"].append(*it);
        }
`, jsonName, fieldName, fieldName, jsonName))

			case types.JSONInt:
				buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value(Json::arrayValue);
        for (std::vector<int64_t>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
            v["%s"].append(Json::Value::Int64(*it));
        }
`, jsonName, fieldName, fieldName, jsonName))

			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value(Json::arrayValue);
        for (std::vector<double>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
            v["%s"].append(*it);
        }
`, jsonName, fieldName, fieldName, jsonName))

			case types.JSONBool:
				buf.WriteString(fmt.Sprintf(`        v["%s"] = Json::Value(Json::arrayValue);
        for (std::vector<bool>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
            v["%s"].append(*it);
        }
`, jsonName, fieldName, fieldName, jsonName))

			default:
				buf.WriteString(fmt.Sprintf(`        v["%s"] = %s;
`, jsonName, fieldName))
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        %s.ToJson(v["%s"]);
`, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v["%s"] = %s;
`, jsonName, fieldName))
		}

	default:
		return "", fmt.Errorf("unknown type in ToJson: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *JsonCppGenerator) getFieldName(name string) string {
	sanitized := nameutil.SanitizeToCppIdentifier(name, g.useCamelCase, false)
	if _, ok := g.usedNames[sanitized]; !ok {
		g.usedNames[sanitized] = 0
	}
	return sanitized
}
