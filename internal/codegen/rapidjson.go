package codegen

import (
	"bytes"
	"fmt"
	"json2cpp/internal/nameutil"
	"json2cpp/internal/types"
)

// RapidJSONGenerator generates C++ code using RapidJSON library
type RapidJSONGenerator struct {
	legacyCpp    bool
	namespace    string
	useCamelCase bool
	optionalNull bool
	stringRef    bool
	usedNames    map[string]int
}

// NewRapidJSONGenerator creates a new RapidJSON code generator
func NewRapidJSONGenerator(cfg Config) *RapidJSONGenerator {
	return &RapidJSONGenerator{
		legacyCpp:    cfg.LegacyCPP,
		namespace:    cfg.Namespace,
		useCamelCase: cfg.CamelCase,
		optionalNull: cfg.OptionalNull,
		stringRef:    cfg.StringRef,
		usedNames:    make(map[string]int),
	}
}

func (g *RapidJSONGenerator) Generate(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header guard and includes
	buf.WriteString(g.generateHeader())
	buf.WriteString("\n\n")

	// Optional type definition (for legacy C++)
	if g.legacyCpp && g.optionalNull {
		buf.WriteString(g.generateOptionalType())
		buf.WriteString("\n\n")
	}

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Struct definitions (sorted by dependencies)
	types.SortStructs(info.Structs)
	for i, s := range info.Structs {
		if i > 0 {
			buf.WriteString("\n\n")
		}
		str, err := g.generateStruct(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(str)
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n\n} // namespace ")
		buf.WriteString(g.namespace)
	}

	return buf.String(), nil
}

func (g *RapidJSONGenerator) generateHeader() string {
	return `// Auto-generated by json2cpp
// DO NOT EDIT

#pragma once

#include <string>
#include <vector>
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"`
}

func (g *RapidJSONGenerator) generateOptionalType() string {
	return `// pre-C++11 compatible Optional implementation
template<typename T>
struct Optional {
    bool has;
    T value;

    Optional() : has(false) {}
    Optional(const T& v) : has(true), value(v) {}

    bool IsValid() const { return has; }
    const T& Get() const { return value; }
    T& Get() { return value; }
    void Set(const T& v) { has = true; value = v; }
    void Clear() { has = false; }
};

typedef Optional<int> OptionalInt;
typedef Optional<int64_t> OptionalInt64;
typedef Optional<double> OptionalDouble;
typedef Optional<bool> OptionalBool;
typedef Optional<std::string> OptionalString;`
}

func (g *RapidJSONGenerator) generateStruct(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Reset usedNames for each struct to avoid collisions across different structs
	g.usedNames = make(map[string]int)

	// Struct definition
	buf.WriteString(fmt.Sprintf("struct %s {\n", s.Name))

	// Member variables
	for _, f := range s.Fields {
		member, err := g.generateMember(f)
		if err != nil {
			return "", err
		}
		buf.WriteString("    " + member + "\n")
	}

	// FromJson / ToJson methods
	fromJson, err := g.generateFromJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n")
	buf.WriteString(fromJson)

	toJson, err := g.generateToJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n\n")
	buf.WriteString(toJson)

	buf.WriteString("\n};")

	return buf.String(), nil
}

func (g *RapidJSONGenerator) generateMember(f *types.Field) (string, error) {
	var memberType string

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			memberType = "Optional<null_t>"
		} else {
			memberType = "bool" // null is replaced with bool
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalBool"
		} else {
			memberType = "bool"
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalInt64"
		} else {
			memberType = "int64_t"
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalDouble"
		} else {
			memberType = "double"
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			memberType = "OptionalString"
		} else if g.stringRef {
			memberType = "const std::string&"
		} else {
			memberType = "std::string"
		}

	case types.JSONArray:
		if f.NestedType != nil {
			memberType = fmt.Sprintf("std::vector<%s>", f.NestedType.Name)
		} else {
			switch f.ElemType {
			case types.JSONString:
				memberType = "std::vector<std::string>"
			case types.JSONInt:
				memberType = "std::vector<int64_t>"
			case types.JSONFloat:
				memberType = "std::vector<double>"
			case types.JSONBool:
				memberType = "std::vector<bool>"
			default:
				memberType = "std::vector<rapidjson::Value>"
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			memberType = f.NestedType.Name
		} else {
			memberType = "rapidjson::Value"
		}

	default:
		return "", fmt.Errorf("unknown type: %v", f.Type)
	}

	fieldName := g.getFieldName(f.Name)
	return fmt.Sprintf("%s %s;", memberType, fieldName), nil
}

func (g *RapidJSONGenerator) generateFromJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("    void FromJson(const rapidjson::Value& v) {\n"))

	for _, f := range s.Fields {
		code, err := g.generateFromJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *RapidJSONGenerator) generateFromJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	// Pre-C++11 compilers require explicit HasMember and IsXXX checks
	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsNull()) {
            %s.Clear();
        } else {
            %s.has = false;
        }
`, jsonName, jsonName, fieldName, fieldName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsBool()) {
            %s.Set(v["%s"].GetBool());
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsBool()) {
            %s = v["%s"].GetBool();
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsInt64()) {
            %s.Set(v["%s"].GetInt64());
        } else if (v.HasMember("%s") && v["%s"].IsInt()) {
            %s.Set(static_cast<int64_t>(v["%s"].GetInt()));
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsInt64()) {
            %s = v["%s"].GetInt64();
        } else if (v.HasMember("%s") && v["%s"].IsInt()) {
            %s = static_cast<int64_t>(v["%s"].GetInt());
        }
`, jsonName, jsonName, fieldName, jsonName, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsDouble()) {
            %s.Set(v["%s"].GetDouble());
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsDouble()) {
            %s = v["%s"].GetDouble();
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsString()) {
            %s.Set(std::string(v["%s"].GetString()));
        } else {
            %s.Clear();
        }
`, jsonName, jsonName, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsString()) {
            %s = std::string(v["%s"].GetString());
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            const rapidjson::Value& arr = v["%s"];
            %s.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                %s item;
                item.FromJson(arr[i]);
                %s.push_back(item);
            }
        }
`, jsonName, jsonName, jsonName, fieldName, f.NestedType.Name, fieldName))
		} else {
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            const rapidjson::Value& arr = v["%s"];
            %s.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                if (arr[i].IsString()) {
                    %s.push_back(std::string(arr[i].GetString()));
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName))

			case types.JSONInt:
				buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            const rapidjson::Value& arr = v["%s"];
            %s.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                if (arr[i].IsInt64()) %s.push_back(arr[i].GetInt64());
                else if (arr[i].IsInt()) %s.push_back(static_cast<int64_t>(arr[i].GetInt()));
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName, fieldName))

			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            const rapidjson::Value& arr = v["%s"];
            %s.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                if (arr[i].IsDouble()) %s.push_back(arr[i].GetDouble());
                else if (arr[i].IsInt64()) %s.push_back(static_cast<double>(arr[i].GetInt64()));
                else if (arr[i].IsInt()) %s.push_back(static_cast<double>(arr[i].GetInt()));
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName, fieldName, fieldName))

			case types.JSONBool:
				buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            const rapidjson::Value& arr = v["%s"];
            %s.clear();
            for (rapidjson::SizeType i = 0; i < arr.Size(); ++i) {
                if (arr[i].IsBool()) {
                    %s.push_back(arr[i].GetBool());
                }
            }
        }
`, jsonName, jsonName, jsonName, fieldName, fieldName))

			default:
				buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsArray()) {
            %s = v["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsObject()) {
            %s.FromJson(v["%s"]);
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (v.HasMember("%s") && v["%s"].IsObject()) {
            %s = v["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	default:
		return "", fmt.Errorf("unknown type in FromJson: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *RapidJSONGenerator) generateToJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("    void ToJson(rapidjson::Value& v, rapidjson::Document::AllocatorType& a) const {\n"))

	for _, f := range s.Fields {
		code, err := g.generateToJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *RapidJSONGenerator) generateToJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v.AddMember("%s", rapidjson::Value().SetNull(), a);
        }
`, fieldName, jsonName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v.AddMember("%s", rapidjson::Value(%s.Get()), a);
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v.AddMember("%s", rapidjson::Value(%s), a);
`, jsonName, fieldName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v.AddMember("%s", rapidjson::Value().SetInt64(%s.Get()), a);
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v.AddMember("%s", rapidjson::Value().SetInt64(%s), a);
`, jsonName, fieldName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            v.AddMember("%s", rapidjson::Value().SetDouble(%s.Get()), a);
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v.AddMember("%s", rapidjson::Value().SetDouble(%s), a);
`, jsonName, fieldName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.IsValid()) {
            rapidjson::Value str_val;
            str_val.SetString(%s.Get().c_str(), a);
            v.AddMember("%s", str_val, a);
        }
`, fieldName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value str_val;
            str_val.SetString(%s.c_str(), a);
            v.AddMember("%s", str_val, a);
        }
`, fieldName, jsonName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<%s>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
                rapidjson::Value item_val(rapidjson::kObjectType);
                it->ToJson(item_val, a);
                arr.PushBack(item_val, a);
            }
            v.AddMember("%s", arr, a);
        }
`, f.NestedType.Name, fieldName, fieldName, jsonName))
		} else {
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<std::string>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
                rapidjson::Value item_val;
                item_val.SetString(it->c_str(), a);
                arr.PushBack(item_val, a);
            }
            v.AddMember("%s", arr, a);
        }
`, fieldName, fieldName, jsonName))

			case types.JSONInt:
				buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<int64_t>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
                arr.PushBack(rapidjson::Value().SetInt64(*it), a);
            }
            v.AddMember("%s", arr, a);
        }
`, fieldName, fieldName, jsonName))

			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<double>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
                arr.PushBack(rapidjson::Value().SetDouble(*it), a);
            }
            v.AddMember("%s", arr, a);
        }
`, fieldName, fieldName, jsonName))

			case types.JSONBool:
				buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value arr(rapidjson::kArrayType);
            for (std::vector<bool>::const_iterator it = %s.begin(); it != %s.end(); ++it) {
                arr.PushBack(rapidjson::Value(*it), a);
            }
            v.AddMember("%s", arr, a);
        }
`, fieldName, fieldName, jsonName))

			default:
				buf.WriteString(fmt.Sprintf(`        v.AddMember("%s", %s, a);
`, jsonName, fieldName))
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        {
            rapidjson::Value obj_val(rapidjson::kObjectType);
            %s.ToJson(obj_val, a);
            v.AddMember("%s", obj_val, a);
        }
`, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        v.AddMember("%s", %s, a);
`, jsonName, fieldName))
		}

	default:
		return "", fmt.Errorf("unknown type in ToJson: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *RapidJSONGenerator) getFieldName(name string) string {
	// Final sanitizer + uniqueness enforcement.
	// Ensure generator-level camelCase preference is respected.
	sanitized := nameutil.SanitizeToCppIdentifier(name, g.useCamelCase, false)
	if _, ok := g.usedNames[sanitized]; !ok {
		g.usedNames[sanitized] = 0
	}
	// Always return the sanitized name without suffix
	// The usedNames map is only used for tracking, not for generating suffixes
	return sanitized
}
