package codegen

import (
	"bytes"
	"fmt"
	"json2cpp/internal/nameutil"
	"json2cpp/internal/types"
)

// NlohmannGenerator generates C++ code using nlohmann/json library
type NlohmannGenerator struct {
	legacyCpp    bool
	namespace    string
	useCamelCase bool
	optionalNull bool
	stringRef    bool
	usedNames    map[string]int
}

// NewNlohmannGenerator creates a new nlohmann/json code generator
func NewNlohmannGenerator(cfg Config) *NlohmannGenerator {
	return &NlohmannGenerator{
		legacyCpp:    cfg.LegacyCPP,
		namespace:    cfg.Namespace,
		useCamelCase: cfg.CamelCase,
		optionalNull: cfg.OptionalNull,
		stringRef:    cfg.StringRef,
		usedNames:    make(map[string]int),
	}
}

func (g *NlohmannGenerator) Generate(info *types.TypeInfo) (string, error) {
	var buf bytes.Buffer

	// Header guard and includes
	buf.WriteString(g.generateHeader())
	buf.WriteString("\n\n")

	// Optional type definition if needed
	if g.optionalNull {
		if g.legacyCpp {
			// Use custom Optional for pre-C++11
			buf.WriteString(g.generateOptionalType())
		} else {
			// Use std::optional for C++17+
			buf.WriteString(`#include <optional>

template<typename T>
using Optional = std::optional<T>;
`)
		}
		buf.WriteString("\n\n")
	}

	// Namespace start
	if g.namespace != "" {
		buf.WriteString(fmt.Sprintf("namespace %s {\n\n", g.namespace))
	}

	// Struct definitions (sorted by dependencies)
	types.SortStructs(info.Structs)
	for i, s := range info.Structs {
		if i > 0 {
			buf.WriteString("\n\n")
		}
		str, err := g.generateStruct(s)
		if err != nil {
			return "", err
		}
		buf.WriteString(str)
	}

	// Namespace end
	if g.namespace != "" {
		buf.WriteString("\n\n} // namespace ")
		buf.WriteString(g.namespace)
	}

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateHeader() string {
	return `// Auto-generated by json2cpp
// DO NOT EDIT
// Parser: nlohmann/json

#pragma once

#include <string>
#include <vector>
#include <nlohmann/json.hpp>`
}

func (g *NlohmannGenerator) generateOptionalType() string {
	return `// pre-C++11 compatible Optional implementation
template<typename T>
struct Optional {
    bool has;
    T value;

    Optional() : has(false) {}
    Optional(const T& v) : has(true), value(v) {}

    bool has_value() const { return has; }
    const T& value_or(const T& default_value) const { return has ? value : default_value; }
    T& operator*() { return value; }
    const T& operator*() const { return value; }
    void reset() { has = false; }
};`
}

func (g *NlohmannGenerator) generateStruct(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	// Reset usedNames for each struct
	g.usedNames = make(map[string]int)

	// Struct definition
	buf.WriteString(fmt.Sprintf("struct %s {\n", s.Name))

	// Member variables
	for _, f := range s.Fields {
		member, err := g.generateMember(f)
		if err != nil {
			return "", err
		}
		buf.WriteString("    " + member + "\n")
	}

	// from_json method
	fromJson, err := g.generateFromJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n")
	buf.WriteString(fromJson)

	// to_json method
	toJson, err := g.generateToJson(s)
	if err != nil {
		return "", err
	}
	buf.WriteString("\n\n")
	buf.WriteString(toJson)

	buf.WriteString("\n};")

	// ADL helper functions
	buf.WriteString("\n\n")
	buf.WriteString(g.generateADLHelpers(s))

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateMember(f *types.Field) (string, error) {
	var memberType string

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			memberType = "Optional<bool>"
		} else {
			memberType = "bool"
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			memberType = "Optional<bool>"
		} else {
			memberType = "bool"
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			memberType = "Optional<int64_t>"
		} else {
			memberType = "int64_t"
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			memberType = "Optional<double>"
		} else {
			memberType = "double"
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			memberType = "Optional<std::string>"
		} else if g.stringRef {
			memberType = "const std::string&"
		} else {
			memberType = "std::string"
		}

	case types.JSONArray:
		if f.NestedType != nil {
			memberType = fmt.Sprintf("std::vector<%s>", f.NestedType.Name)
		} else {
			switch f.ElemType {
			case types.JSONString:
				memberType = "std::vector<std::string>"
			case types.JSONInt:
				memberType = "std::vector<int64_t>"
			case types.JSONFloat:
				memberType = "std::vector<double>"
			case types.JSONBool:
				memberType = "std::vector<bool>"
			default:
				memberType = "std::vector<nlohmann::json>"
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			memberType = f.NestedType.Name
		} else {
			memberType = "nlohmann::json"
		}

	default:
		return "", fmt.Errorf("unknown type: %v", f.Type)
	}

	fieldName := g.getFieldName(f.Name)
	return fmt.Sprintf("%s %s;", memberType, fieldName), nil
}

func (g *NlohmannGenerator) generateFromJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("    void from_json(const nlohmann::json& j) {\n")

	for _, f := range s.Fields {
		code, err := g.generateFromJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateFromJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_null()) {
            %s.reset();
        }
`, jsonName, jsonName, fieldName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_boolean()) {
            %s = j["%s"].get<bool>();
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s")) {
            %s = j["%s"].get<bool>();
        }
`, jsonName, fieldName, jsonName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_number_integer()) {
            %s = j["%s"].get<int64_t>();
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s")) {
            %s = j["%s"].get<int64_t>();
        }
`, jsonName, fieldName, jsonName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_number()) {
            %s = j["%s"].get<double>();
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s")) {
            %s = j["%s"].get<double>();
        }
`, jsonName, fieldName, jsonName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_string()) {
            %s = j["%s"].get<std::string>();
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s")) {
            %s = j["%s"].get<std::string>();
        }
`, jsonName, fieldName, jsonName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s.clear();
            for (const auto& item : j["%s"]) {
                %s obj;
                obj.from_json(item);
                %s.push_back(obj);
            }
        }
`, jsonName, jsonName, fieldName, jsonName, f.NestedType.Name, fieldName))
		} else {
			switch f.ElemType {
			case types.JSONString:
				buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s = j["%s"].get<std::vector<std::string>>();
        }
`, jsonName, jsonName, fieldName, jsonName))

			case types.JSONInt:
				buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s = j["%s"].get<std::vector<int64_t>>();
        }
`, jsonName, jsonName, fieldName, jsonName))

			case types.JSONFloat:
				buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s = j["%s"].get<std::vector<double>>();
        }
`, jsonName, jsonName, fieldName, jsonName))

			case types.JSONBool:
				buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s = j["%s"].get<std::vector<bool>>();
        }
`, jsonName, jsonName, fieldName, jsonName))

			default:
				buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_array()) {
            %s = j["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
			}
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_object()) {
            %s.from_json(j["%s"]);
        }
`, jsonName, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        if (j.contains("%s") && j["%s"].is_object()) {
            %s = j["%s"];
        }
`, jsonName, jsonName, fieldName, jsonName))
		}

	default:
		return "", fmt.Errorf("unknown type in from_json: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateToJson(s *types.Struct) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("    nlohmann::json to_json() const {\n")
	buf.WriteString("        nlohmann::json j;\n")

	for _, f := range s.Fields {
		code, err := g.generateToJsonField(f)
		if err != nil {
			return "", err
		}
		buf.WriteString(code)
	}

	buf.WriteString("        return j;\n")
	buf.WriteString("    }")

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateToJsonField(f *types.Field) (string, error) {
	var buf bytes.Buffer
	fieldName := g.getFieldName(f.Name)
	jsonName := f.JSONName

	switch f.Type {
	case types.JSONNull:
		if g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = nullptr;
`, jsonName))
		}

	case types.JSONBool:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.has_value()) {
            j["%s"] = *%s;
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONInt:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.has_value()) {
            j["%s"] = *%s;
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONFloat:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.has_value()) {
            j["%s"] = *%s;
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONString:
		if f.IsOptional && g.optionalNull {
			buf.WriteString(fmt.Sprintf(`        if (%s.has_value()) {
            j["%s"] = *%s;
        }
`, fieldName, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONArray:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = nlohmann::json::array();
        for (const auto& item : %s) {
            j["%s"].push_back(item.to_json());
        }
`, jsonName, fieldName, jsonName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	case types.JSONObject:
		if f.NestedType != nil {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s.to_json();
`, jsonName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf(`        j["%s"] = %s;
`, jsonName, fieldName))
		}

	default:
		return "", fmt.Errorf("unknown type in to_json: %v", f.Type)
	}

	return buf.String(), nil
}

func (g *NlohmannGenerator) generateADLHelpers(s *types.Struct) string {
	return fmt.Sprintf(`// ADL (Argument-Dependent Lookup) serialization helpers
inline void from_json(const nlohmann::json& j, %s& obj) {
    obj.from_json(j);
}

inline void to_json(nlohmann::json& j, const %s& obj) {
    j = obj.to_json();
}`, s.Name, s.Name)
}

func (g *NlohmannGenerator) getFieldName(name string) string {
	sanitized := nameutil.SanitizeToCppIdentifier(name, g.useCamelCase, false)
	if _, ok := g.usedNames[sanitized]; !ok {
		g.usedNames[sanitized] = 0
	}
	return sanitized
}
